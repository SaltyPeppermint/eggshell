# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing
from . import arithmetic
from . import halide
from . import rise
from . import simple

class Node:
    raw_name: str
    arity: int
    nth_child: int
    dfs_order: int
    depth: int
    id: int
    value: typing.Optional[str]
    name: str

class TreeData:
    nodes: list[Node]
    def transposed_adjacency(self) -> list[list[int]]:
        ...

    def anc_matrix(self, max:int) -> list[list[int]]:
        r"""
        Gives a matrix that describes the relationship of an ancestor to a child as a distance between them
        max describes the maximum distance to be encoded. Max is used to indicate that
        no relationship between nodes exists OR the distance is bigger than max
        
        # Errors
        
        If distance cannot be converted to i32
        """
        ...

    def sib_matrix(self, max:int) -> list[list[int]]:
        r"""
        Gives a matrix that describes the sibling relationship in nodes
        max describes the maximum distance to be encoded. Max is used to indicate that
        no relationship between nodes exists OR the distance is bigger than max
        
        # Errors
        
        Will error if any sibling distance is greater than i32
        """
        ...

    def count_symbols(self, n_symbols:int, n_vars:int) -> list[int]:
        ...

    def values(self) -> list[str]:
        ...

    def names(self) -> list[str]:
        ...

    def arity(self, position:int) -> int:
        ...

    def depth(self) -> int:
        ...

    def size(self) -> int:
        ...

    def simple_feature_names(self, symbol_names:typing.Sequence[str], var_names:typing.Sequence[str]) -> list[str]:
        ...

    def simple_features(self, n_symbols:int, n_vars:int) -> list[float]:
        ...

    @staticmethod
    def batch_simple_features(tree_datas:typing.Sequence[TreeData], n_symbols:int, n_vars:int) -> list[list[float]]:
        ...


